export interface Result<T> {
    amountDone: number;
    amountStarted: number;
    amountResolved: number;
    amountRejected: number;
    amountNextCheckFalsey: number;
    rejectedIndexes: number[];
    resolvedIndexes: number[];
    nextCheckFalseyIndexes: number[];
    taskResults: T[];
}
export interface Options {
    maxInProgress?: number;
    failFast?: boolean;
    progressCallback?: <T>(result: Result<T>) => void;
    nextCheck?: nextTaskCheck;
}
export declare type Task<T> = () => Promise<T>;
export declare type Tasks<T> = Array<Task<T>>;
export declare type nextTaskCheck = <T>(status: Result<T>, tasks: Tasks<T>) => Promise<boolean>;
/**
 * Raw throttle function, which can return extra meta data.
 * @param tasks required array of tasks to be executed
 * @param options Options object
 * @returns {Promise}
 */
export declare function raw<T>(tasks: Tasks<T>, options?: Options): Promise<Result<T>>;
/**
 * Simply run all the promises after each other, so in synchronous manner
 * @param tasks required array of tasks to be executed
 * @param options Options object
 * @returns {Promise}
 */
export declare function sync<T>(tasks: Tasks<T>, options?: Options): Promise<T[]>;
/**
 * Exposes the same behaviour as Promise.All(), but throttled!
 * @param tasks required array of tasks to be executed
 * @param options Options object
 * @returns {Promise}
 */
export declare function all<T>(tasks: Tasks<T>, options?: Options): Promise<T[]>;
